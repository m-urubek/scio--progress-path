@page "/groups/{GroupId:int}"
@attribute [Authorize]
@using System.Text.Json
@using Microsoft.AspNetCore.SignalR.Client
@using ProgressPath.Models
@using ProgressPath.Data
@using Microsoft.EntityFrameworkCore
@implements IAsyncDisposable
@inject IGroupService GroupService
@inject IStudentSessionService StudentSessionService
@inject IAlertService AlertService
@inject IChatService ChatService
@inject IAuthenticationService AuthService
@inject IQRCodeService QRCodeService
@inject IHubNotificationService HubNotificationService
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject NavigationManager NavigationManager
@inject IConfiguration Configuration
@inject IJSRuntime JSRuntime
@inject IDbContextFactory<ProgressPathDbContext> DbContextFactory
@inject ILogger<GroupDashboard> Logger

<PageTitle>@(group != null ? group.Name + " - Progress Path" : "Group Dashboard - Progress Path")</PageTitle>

<div class="container mx-auto py-8 px-4">
    <div class="mb-6">
        <a href="/groups" class="text-sm opacity-75 hover:opacity-100 transition">← Back to Groups</a>
    </div>

    @if (isLoading)
    {
        <div class="glow-container p-8 text-center">
            <div class="flex items-center justify-center gap-3">
                <div class="animate-spin h-6 w-6 rounded-full" style="border: 3px solid rgba(34, 211, 216, 0.3); border-top-color: var(--color-tertiary);"></div>
                <p class="text-lg opacity-75">Loading dashboard...</p>
            </div>
        </div>
    }
    else if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="glow-container p-8" style="border-color: rgba(255, 107, 157, 0.5);">
            <p class="text-lg" style="color: var(--color-primary);">@errorMessage</p>
            <button class="glow-button mt-4" @onclick="NavigateToGroups">
                Return to Groups
            </button>
        </div>
    }
    else if (group != null)
    {
        <!-- Group Header -->
        <div class="glow-container p-6 mb-6">
            <div class="flex flex-col md:flex-row items-start md:items-center justify-between gap-4">
                <div>
                    <h1 class="text-3xl font-bold gradient-text mb-2">
                        @group.Name
                    </h1>
                    <p class="text-sm opacity-75">
                        @(sessions?.Count() ?? 0) students • Goal: @group.GoalDescription
                    </p>
                </div>
                <div class="flex items-center gap-4">
                    <button class="glow-button" @onclick="ToggleQRCode">
                        @if (showQRCode)
                        {
                            <span>Hide QR Code</span>
                        }
                        else
                        {
                            <span>Show QR Code</span>
                        }
                    </button>
                </div>
            </div>

            @if (showQRCode && !string.IsNullOrEmpty(qrCodeDataUri))
            {
                <div class="mt-6 pt-6" style="border-top: 1px solid rgba(34, 211, 216, 0.2);">
                    <div class="flex flex-col md:flex-row items-center gap-6">
                        <div class="inner-card p-4">
                            <img src="@qrCodeDataUri" alt="QR Code to join group" class="w-48 h-48 rounded-lg" />
                        </div>
                        <div class="text-center md:text-left">
                            <p class="text-sm opacity-75 mb-1">Join Code</p>
                            <p class="text-2xl font-mono font-bold tracking-widest" style="color: var(--color-tertiary);">
                                @group.JoinCode
                            </p>
                            <p class="text-sm opacity-75 mt-3 mb-1">Join URL</p>
                            <p class="text-sm font-mono" style="color: var(--color-tertiary);">
                                @joinUrl
                            </p>
                        </div>
                    </div>
                </div>
            }
        </div>

        <!-- Student List Section -->
        <div class="glow-container p-6">
            <h2 class="text-xl font-semibold gradient-text-pink mb-4">Students</h2>

            @if (sessions == null || !sessions.Any())
            {
                <div class="inner-card text-center py-8">
                    <p class="opacity-75">No students have joined yet.</p>
                    <p class="text-sm opacity-50 mt-2">Share the QR code above to invite students.</p>
                </div>
            }
            else
            {
                <div class="student-list-container space-y-2">
                    @foreach (var session in GetSortedSessions())
                    {
                        var alert = GetSessionAlert(session.Id);
                        var isExpanded = expandedStudents.Contains(session.Id);

                        <StudentRow @key="session.Id"
                                    Session="session"
                                    CurrentProgress="session.CurrentProgress"
                                    IsCompleted="session.IsCompleted"
                                    GoalType="group.GoalType"
                                    TotalSteps="group.TotalSteps"
                                    ActiveAlert="alert"
                                    IsExpanded="isExpanded"
                                    OnToggleExpansion="() => ToggleExpansion(session.Id)"
                                    OnResolveAlert="HandleResolveAlert"
                                    OnViewFullChat="HandleViewFullChat" />
                    }
                </div>
            }
        </div>
    }
</div>

<ToastContainer Toasts="toasts" OnDismiss="RemoveToast" />

@* Chat History Modal - rendered at page level to avoid CSS containment issues (REQ-DASH-016) *@
@if (showChatModal && chatModalSession != null)
{
    <ChatHistoryModal SessionId="@chatModalSession.Id"
                     Nickname="@chatModalSession.Nickname"
                     GroupId="@GroupId"
                     GoalType="@(group?.GoalType ?? GoalType.Binary)"
                     TotalSteps="@group?.TotalSteps"
                     CurrentProgress="@chatModalSession.CurrentProgress"
                     IsCompleted="@chatModalSession.IsCompleted"
                     IsVisible="true"
                     IsEmbedded="false"
                     OnClose="CloseChatModal" />
}

@code {
    /// <summary>
    /// Route parameter: the group ID from the URL.
    /// </summary>
    [Parameter]
    public int GroupId { get; set; }

    // Internal state
    private Group? group;
    private IEnumerable<StudentSession>? sessions;
    private IEnumerable<HelpAlert>? unresolvedAlerts;
    private Dictionary<int, HelpAlert?> sessionAlerts = new();
    private bool isLoading = true;
    private string? errorMessage;
    private User? currentUser;
    private string? qrCodeDataUri;
    private string? joinUrl;
    private bool showQRCode = false;
    private HashSet<int> expandedStudents = new();
    private List<ToastMessage> toasts = new();

    // Chat modal state
    private bool showChatModal = false;
    private StudentSession? chatModalSession;

    // SignalR connection
    private HubConnection? _hubConnection;
    private CancellationTokenSource? _disposalTokenSource;

    /// <summary>
    /// Loads the group data and initializes the dashboard.
    /// </summary>
    protected override async Task OnInitializedAsync()
    {
        _disposalTokenSource = new CancellationTokenSource();

        try
        {
            // Get current user
            var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
            currentUser = await AuthService.GetCurrentUserAsync(authState.User);

            if (currentUser == null)
            {
                errorMessage = "Unable to load user information. Please sign in again.";
                isLoading = false;
                return;
            }

            // Load group with authorization check
            await using var dbContext = await DbContextFactory.CreateDbContextAsync();
            group = await dbContext.Groups
                .AsNoTracking()
                .Include(g => g.StudentSessions)
                    .ThenInclude(s => s.HelpAlerts)
                .FirstOrDefaultAsync(g => g.Id == GroupId && g.TeacherId == currentUser.Id);

            if (group == null)
            {
                errorMessage = "Group not found or you don't have permission to view it.";
                isLoading = false;
                return;
            }

            // Redirect unconfirmed groups to confirmation page
            if (!group.IsConfirmed)
            {
                NavigationManager.NavigateTo($"/groups/{GroupId}/confirm");
                return;
            }

            // Store sessions reference
            sessions = group.StudentSessions?.ToList() ?? new List<StudentSession>();

            // Extract unresolved alerts from already-loaded data (avoids using scoped DbContext)
            unresolvedAlerts = sessions
                .SelectMany(s => s.HelpAlerts ?? Enumerable.Empty<HelpAlert>())
                .Where(a => !a.IsResolved)
                .OrderByDescending(a => a.CreatedAt)
                .ToList();

            // Build session alerts dictionary
            BuildSessionAlertsMap();

            // Generate QR code
            var baseUrl = Configuration["ApplicationBaseUrl"] ?? NavigationManager.BaseUri.TrimEnd('/');
            joinUrl = $"{baseUrl}/join/{group.JoinCode}";
            qrCodeDataUri = QRCodeService.GenerateQRCodeBase64(joinUrl);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error loading group dashboard for GroupId {GroupId}", GroupId);
            errorMessage = "An error occurred while loading the dashboard.";
        }
        finally
        {
            isLoading = false;
        }
    }

    /// <summary>
    /// Initializes the SignalR connection after the first render.
    /// </summary>
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && group != null)
        {
            try
            {
                // Create SignalR hub connection
                // Use internal URL for server-side connection (Docker runs on port 5000 internally)
                var hubUrl = GetSignalRHubUrl();
                _hubConnection = new HubConnectionBuilder()
                    .WithUrl(hubUrl)
                    .WithAutomaticReconnect()
                    .Build();

                // Register event handlers
                RegisterHubEventHandlers();

                // Start the connection
                await _hubConnection.StartAsync(_disposalTokenSource?.Token ?? CancellationToken.None);

                // Join the group channel
                await _hubConnection.InvokeAsync("JoinGroupChannel", group.Id.ToString());

                Logger.LogInformation("Connected to SignalR hub for group {GroupId}", group.Id);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Failed to connect to SignalR hub");
            }
        }
    }

    /// <summary>
    /// Registers all SignalR event handlers.
    /// </summary>
    private void RegisterHubEventHandlers()
    {
        if (_hubConnection == null) return;

        // ReceiveProgress handler - updates student progress in real-time
        // Uses JsonElement because System.Text.Json (the default SignalR protocol) doesn't
        // support dynamic member access on deserialized payloads.
        _hubConnection.On<JsonElement>("ReceiveProgress", (payload) =>
        {
            try
            {
                int sessionId = payload.GetProperty("SessionId").GetInt32();
                int progress = payload.GetProperty("Progress").GetInt32();
                bool isCompleted = payload.GetProperty("IsCompleted").GetBoolean();

                var session = sessions?.FirstOrDefault(s => s.Id == sessionId);
                if (session != null)
                {
                    session.CurrentProgress = progress;
                    session.IsCompleted = isCompleted;
                    InvokeAsync(StateHasChanged);
                }
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error handling ReceiveProgress event");
            }
        });

        // ReceiveAlert handler - adds new alerts to the dashboard
        _hubConnection.On<JsonElement>("ReceiveAlert", (payload) =>
        {
            try
            {
                int alertId = payload.GetProperty("Id").GetInt32();
                int sessionId = payload.GetProperty("SessionId").GetInt32();
                string alertTypeStr = payload.GetProperty("AlertType").GetString() ?? "";
                string nickname = payload.GetProperty("Nickname").GetString() ?? "Unknown";
                DateTime createdAt = payload.GetProperty("CreatedAt").GetDateTime();

                // Parse alert type
                if (!Enum.TryParse<AlertType>(alertTypeStr, out var alertType))
                {
                    Logger.LogWarning("Unknown alert type: {AlertType}", alertTypeStr);
                    return;
                }

                // Create alert object
                var alert = new HelpAlert
                {
                    Id = alertId,
                    StudentSessionId = sessionId,
                    AlertType = alertType,
                    CreatedAt = createdAt,
                    IsResolved = false
                };

                // Update session alerts map
                sessionAlerts[sessionId] = alert;

                // Update session's HasActiveAlert
                var session = sessions?.FirstOrDefault(s => s.Id == sessionId);
                if (session != null)
                {
                    session.HasActiveAlert = true;
                    session.AlertType = alertType;
                }

                // Add toast notification (REQ-DASH-013)
                var alertTypeDisplay = alertType == AlertType.Inactivity ? "Inactivity" : "Off-topic";
                toasts.Add(new ToastMessage
                {
                    Id = Guid.NewGuid().ToString(),
                    Message = $"New Alert: {nickname} - {alertTypeDisplay}",
                    Type = "alert",
                    Nickname = nickname,
                    CreatedAt = DateTime.UtcNow
                });

                InvokeAsync(StateHasChanged);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error handling ReceiveAlert event");
            }
        });

        // AlertResolved handler - removes resolved alerts from display
        _hubConnection.On<int>("AlertResolved", (alertId) =>
        {
            try
            {
                // Find and remove alert from sessionAlerts
                var sessionId = sessionAlerts.FirstOrDefault(kvp => kvp.Value?.Id == alertId).Key;
                if (sessionId != 0)
                {
                    sessionAlerts[sessionId] = null;

                    var session = sessions?.FirstOrDefault(s => s.Id == sessionId);
                    if (session != null)
                    {
                        session.HasActiveAlert = false;
                        session.AlertType = null;
                    }
                }

                InvokeAsync(StateHasChanged);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error handling AlertResolved event");
            }
        });

        // StudentResumedActivity handler - shows toast notification (REQ-DASH-012, REQ-AI-017)
        _hubConnection.On<string>("StudentResumedActivity", (nickname) =>
        {
            try
            {
                toasts.Add(new ToastMessage
                {
                    Id = Guid.NewGuid().ToString(),
                    Message = $"{nickname} has resumed activity",
                    Type = "resumed",
                    Nickname = nickname,
                    CreatedAt = DateTime.UtcNow
                });

                InvokeAsync(StateHasChanged);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error handling StudentResumedActivity event");
            }
        });

        // StudentJoined handler - adds new student to the list
        _hubConnection.On<JsonElement>("StudentJoined", (payload) =>
        {
            try
            {
                int id = payload.GetProperty("Id").GetInt32();
                string nickname = payload.GetProperty("Nickname").GetString() ?? "Unknown";
                int currentProgress = payload.GetProperty("CurrentProgress").GetInt32();
                bool isCompleted = payload.GetProperty("IsCompleted").GetBoolean();
                DateTime joinedAt = payload.GetProperty("JoinedAt").GetDateTime();

                // Check if session already exists
                if (sessions?.Any(s => s.Id == id) == true)
                {
                    return;
                }

                var newSession = new StudentSession
                {
                    Id = id,
                    Nickname = nickname,
                    CurrentProgress = currentProgress,
                    IsCompleted = isCompleted,
                    JoinedAt = joinedAt,
                    GroupId = GroupId
                };

                // Add to sessions list
                var sessionsList = sessions?.ToList() ?? new List<StudentSession>();
                sessionsList.Add(newSession);
                sessions = sessionsList;

                InvokeAsync(StateHasChanged);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error handling StudentJoined event");
            }
        });

        // Handle reconnecting state (REQ-RT-002)
        _hubConnection.Reconnecting += (exception) =>
        {
            Logger.LogWarning(
                exception,
                "SignalR connection lost for group dashboard {GroupId}, attempting to reconnect...",
                GroupId);

            return Task.CompletedTask;
        };

        // Handle reconnection - re-join channel and refresh data
        _hubConnection.Reconnected += async (connectionId) =>
        {
            Logger.LogInformation(
                "SignalR reconnected for group dashboard {GroupId}, connection {ConnectionId}",
                GroupId,
                connectionId);

            try
            {
                // Re-join the group channel
                await _hubConnection.InvokeAsync("JoinGroupChannel", group!.Id.ToString());

                // Refresh sessions and alerts from database
                await using var dbContext = await DbContextFactory.CreateDbContextAsync();

                // Reload sessions
                var refreshedSessions = await dbContext.StudentSessions
                    .Where(s => s.GroupId == GroupId)
                    .AsNoTracking()
                    .ToListAsync();
                sessions = refreshedSessions;

                // Reload unresolved alerts
                unresolvedAlerts = await AlertService.GetUnresolvedAlertsAsync(GroupId);

                // Rebuild session alerts map
                BuildSessionAlertsMap();

                // Update session HasActiveAlert flags
                foreach (var session in sessions)
                {
                    var alert = GetSessionAlert(session.Id);
                    session.HasActiveAlert = alert != null;
                    session.AlertType = alert?.AlertType;
                }

                await InvokeAsync(StateHasChanged);

                Logger.LogInformation(
                    "State restored after reconnection for group {GroupId}: {SessionCount} sessions, {AlertCount} alerts",
                    GroupId,
                    sessions.Count(),
                    unresolvedAlerts?.Count() ?? 0);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error restoring state after reconnection for group {GroupId}", GroupId);
            }
        };

        // Handle permanent connection loss
        _hubConnection.Closed += (exception) =>
        {
            if (exception != null)
            {
                Logger.LogError(
                    exception,
                    "SignalR connection permanently closed for group dashboard {GroupId}",
                    GroupId);
            }
            else
            {
                Logger.LogInformation(
                    "SignalR connection closed for group dashboard {GroupId}",
                    GroupId);
            }

            return Task.CompletedTask;
        };
    }

    /// <summary>
    /// Builds the dictionary mapping session IDs to their active alerts.
    /// </summary>
    private void BuildSessionAlertsMap()
    {
        sessionAlerts.Clear();
        if (unresolvedAlerts == null) return;

        foreach (var alert in unresolvedAlerts)
        {
            // Store the most recent alert per session
            if (!sessionAlerts.ContainsKey(alert.StudentSessionId) ||
                sessionAlerts[alert.StudentSessionId]?.CreatedAt < alert.CreatedAt)
            {
                sessionAlerts[alert.StudentSessionId] = alert;
            }
        }
    }

    /// <summary>
    /// Gets the active alert for a session, if any.
    /// </summary>
    private HelpAlert? GetSessionAlert(int sessionId)
    {
        return sessionAlerts.TryGetValue(sessionId, out var alert) ? alert : null;
    }

    /// <summary>
    /// Gets sessions sorted with alerts at the top (REQ-DASH-009).
    /// </summary>
    private IEnumerable<StudentSession> GetSortedSessions()
    {
        if (sessions == null) return Enumerable.Empty<StudentSession>();

        return sessions
            .OrderByDescending(s => s.HasActiveAlert)
            .ThenByDescending(s => s.JoinedAt);
    }

    /// <summary>
    /// Toggles the expansion state of a student row.
    /// </summary>
    private void ToggleExpansion(int sessionId)
    {
        if (expandedStudents.Contains(sessionId))
        {
            expandedStudents.Remove(sessionId);
        }
        else
        {
            expandedStudents.Add(sessionId);
        }
    }

    /// <summary>
    /// Handles resolving an alert (REQ-DASH-007).
    /// </summary>
    private async Task HandleResolveAlert(int alertId)
    {
        try
        {
            var alert = unresolvedAlerts?.FirstOrDefault(a => a.Id == alertId);
            if (alert == null) return;

            int groupId = GroupId;

            // Resolve the alert
            await AlertService.ResolveAlertAsync(alertId);

            // Notify via SignalR
            await HubNotificationService.NotifyAlertResolvedAsync(groupId, alertId);

            // Update local state
            sessionAlerts[alert.StudentSessionId] = null;

            var session = sessions?.FirstOrDefault(s => s.Id == alert.StudentSessionId);
            if (session != null)
            {
                session.HasActiveAlert = false;
                session.AlertType = null;
            }

            StateHasChanged();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error resolving alert {AlertId}", alertId);
        }
    }

    /// <summary>
    /// Removes a toast notification from the list.
    /// </summary>
    private void RemoveToast(ToastMessage toast)
    {
        toasts.Remove(toast);
        StateHasChanged();
    }

    /// <summary>
    /// Toggles the QR code display.
    /// </summary>
    private void ToggleQRCode()
    {
        showQRCode = !showQRCode;
    }

    /// <summary>
    /// Opens the chat history modal for a specific student session.
    /// </summary>
    private void HandleViewFullChat(int sessionId)
    {
        chatModalSession = sessions?.FirstOrDefault(s => s.Id == sessionId);
        if (chatModalSession != null)
        {
            showChatModal = true;
            StateHasChanged();
        }
    }

    /// <summary>
    /// Closes the chat history modal.
    /// </summary>
    private void CloseChatModal()
    {
        showChatModal = false;
        chatModalSession = null;
        StateHasChanged();
    }

    /// <summary>
    /// Gets the SignalR hub URL, handling Docker environment where internal port differs from external.
    /// </summary>
    private string GetSignalRHubUrl()
    {
        // In Docker, the server runs on port 5000 internally, but NavigationManager may return
        // the host-mapped port (e.g., 5001). For server-side SignalR connections, use internal URL.
        var environment = Configuration["ASPNETCORE_ENVIRONMENT"];
        if (environment == "Development")
        {
            // In Docker dev environment, connect to internal port
            return "http://localhost:5000/progresshub";
        }

        // For production or other environments, use NavigationManager
        return NavigationManager.ToAbsoluteUri("/progresshub").ToString();
    }

    /// <summary>
    /// Navigates back to the groups list.
    /// </summary>
    private void NavigateToGroups()
    {
        NavigationManager.NavigateTo("/groups");
    }

    /// <summary>
    /// Disposes the SignalR connection when the component is disposed.
    /// </summary>
    public async ValueTask DisposeAsync()
    {
        _disposalTokenSource?.Cancel();
        _disposalTokenSource?.Dispose();

        if (_hubConnection != null)
        {
            try
            {
                await _hubConnection.InvokeAsync("LeaveChannels");
                await _hubConnection.DisposeAsync();
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Error disposing SignalR connection");
            }
        }
    }
}
